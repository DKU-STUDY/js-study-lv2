# 3주차: 옵저버 패턴 적용

- [ ] 이론
    - [ ] 옵저버 패턴에 대해 조사하기
    - [ ] Flux 패턴에 대해 조사하기
- [ ] 실습
    - [ ] Class Component에 옵저버 패턴 적용하기

### 옵저버 패턴

옵저버 패턴은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태변화가 있을 때마다 메서드 등을 틍해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다. 관찰자
패턴이라고도 하며, 객체와 옵저버들 간의 일대다 관계를 이루고 있다. 옵저버 패턴에서 주제자(Subject)는 옵저버에 대한 정보가 없으며, 단지 옵저버가 특정한 인터페이스(Interface)를 구현한다는 것만 알고
있다. 즉 옵저버가 무슨 동작을 하는지 모르며, 옵저버는 언제든지 새로 추가되거나 제거될 수 있으며, 새로운 형식의 옵저버를 추가할 때에도 주제에 전혀 영향을 주지 않는다. 이러한 관계를 느슨한 결합이라고 한다.

객체는 주제라고도 하며, 주제 옵저버의 관계의 예시로는 신문사와 구독장의 관계, 유튜브에서 채널과 구독자의 관계 등을 들 수 있다. 정보를 알고자 하는 구독자들이 주제(Subject)와 관계를 맺거나, 더 이상 필요
없을 경우 끊을 수 있으며, 주제는 상태가 변경되면 그 정보를 구독자들에게 알려준다.

옵저버 패턴에서의 객체와 구독자는 서로 긴밀한 관계를 맺을 필요가 없이 인터페이스를 통해 서로간의 느슨한 결합을 이룬다. 주제 객체의 역할을 소식을 발행한다는 의미에서 Publisher라는 키워드, 관찰 객체의
역할을 관찰자라는 의미에서 Observer라는 키워드로 정의해본다면, Publisher 인터페이스는 Observer들을 관리하는 메소드를 가지고 있을 것이다.    
구독을 원하는 Observer를 받아 등록시키고(add), 명단에서 제외하고(delete), 등록된 Observer들에게 정보를 알려주는(notify) 이렇게 3가지의 메소드를 정의해볼 수 있다. Observer
인터페이스는 정보를 업데이트 해주는 Update 메소드를 가지고 있을 것이다.

### __Flux__ 패턴

기본적으로 ****Flux****패턴이 나오기 이전에 가장 많이 쓰이던 디자인 패턴에는 MVC패턴이 있다. MVC패턴은 Model, View, Controller의 3가지 형태로 구분하여 개발하는 소프트웨어 개발
방법론으로, 비지니스 로직과 사용자 인터페이스 요소를 분리시켜 서로 영향이 없게 하였다는 장점이 있지만, 앱이 커지고 복잡해질수록 View와 Model의 의존성이 생기고, Controller를 통해 복잡하게 연결될
수 있어 유지보수가 어려웠다. 이를 보완하기 위해 View와 Model을 분리하고 Presenter로 전달한와 MVP패턴, 데이터 바인딩을 통해 View와 Model의 독립을 달성한 MVVM 패턴 등이 등장했지만,
의존성 문제를 근본적으로 해결하지는 못했다.

**Flux**는 페이스북이 MVC의 문제점을 해결하기 위해 도입한 디자인 패턴이다. 기존의 MVC패턴에서는 어플리케이션의 규모에 비례해 데이터 흐름의 복잡도가 증 가하게 되어, 모델이 늘어날수록 전파해야할 대상도
함께 늘어나게 되고, 결과적으로 데이터의 변경사항을 신속하게 전달하기 어려운 문제점이 있었다. 또한, 각 모델에서 발생한 이벤트가 어플레이케이션 전체로 전파될 때 어떤 변화가 일어날지 흐름을 추적하거나, 에러가 생길
때 그것을 디버깅하는 것이 어려웠다. 페이스북은 MVC패턴의 양방향 데이터 흐름이 이러한 문제점들의 주요 원인이라고 보고, 데이터의 흐름을 단방향으로 바꾸어 보다 예측가능하도록 한 **Flux**) 패턴을
발표하였다.
![**
Flux**패턴 흐름도](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlmfPW%2FbtqBQnTPgIs%2FZ1jmHHdNcOTNiu93kQ9gMk%2Fimg.png)
Flux패턴에서는 ****Store****가 어플리케이션의 모든 데이터를 저장하며, **Dispatcher**가 MVC패턴에서의 Controller의 역할을 한다.
**Dispatche**r는 기본적으로 **Store**에 적용될 콜백함수들이 등록된 곳이라고 할 수 있다. **Action**이 트리거 되면 **Dispatcher**로 전달이 되는데, **Dispatche**r는
발생한 Action을 전달받아 등록된 콜백함수들을 실행하여 **Store** 어떻게 갱신되어야 할지를 **Store**에 전달한다.
**Store**는 여러가지 다른 객체들의 상태를 저장하고 관리하는 곳이다. 보통 어플리케이션 전체의 상태정보를 저장하게 된다.
**Dispatcher**가 실행할 콜백함수에는 데이터가 담긴 객체가 인수로 전달되어야 하는데, 이 전달되는 객체를 **Action**이라고 한다. 

